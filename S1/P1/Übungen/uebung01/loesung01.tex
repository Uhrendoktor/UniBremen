\documentclass{pi1}
\usepackage{bibgerm}

\begin{document}

\maketitle{1}{Leander Staack}{Julius Walczynki}
\section{Primzahlen berechnen}
Primzahlen kann man einfach berechnen, indem man eine Folge aller zahlen ab 2 erzeugt,
\begin{lstlisting}[firstnumber=10]
static void primes(){
	IntStream.iterate(2, i -> i+1)
\end{lstlisting}
nur zahlen behält, die nicht durch kleinere Zahlen teilbar sind
\begin{lstlisting}[firstnumber=12]
	.filter(i -> IntStream.range(2,i).noneMatch(j -> i % j == 0))
\end{lstlisting}
und die verbleibenden Zahlen ausgibt
\begin{lstlisting}[firstnumber=14]
	.forEach(System.out::println);
}
\end{lstlisting}
\textbf{Test}. Nach einem Aufruf von \textit{Primes.primes()} wird jeweils eine Zahl pro Zeile ausgegeben. Die Zahlenfolge 2, 3, 5, 7, 11, 13, 17 usw. sieht korrekt nach Primzahlen aus.

\section{Verbesserungen}
Auch wenn das programm aus Aufgabe 1 schnell ist, merkt man, dass es für größere Primzahlen immer langsamer wird. Folgende Verbesserungen sind denkbar:
\begin{itemize}
\item Man könnte die 2 separat ausgeben und danach nur noch ungerade Zahlen erzeugen.
\item Man muss eigentlich nur testen, ob eine Zahl $i$ durch keine Zahl $j\in\left[ 2...\lfloor\sqrt{i}\rfloor\right]$ teilbar ist.
\item Bei bekannter Obergrenze kann man das Sieb des Eratosthenes \cite{mohring-oellrich-08} anwenden (s. Tab. 1).
\end{itemize}
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
&\textbf{2}&\textbf{3}&4\\
\hline
\textbf{5}&6&\textbf{7}&8\\
\hline
9&10&\textbf{11}&12\\
\hline
\textbf{13}&14&15&16\\
\hline
\end{tabular}
\end{center}
Tabelle 1:Sieb des Eratosthenes, Die fett dargestellten Zahlen wurden nicht weggestrichen.

\section*{Literatur}
\bibliography{Referenzen}
\bibliography{Referenzen}

\end{document}

